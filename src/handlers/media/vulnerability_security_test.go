package handlers

import (
	"bytes"
	"encoding/json"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/kevinanielsen/go-fast-cdn/src/database"
	authHandlers "github.com/kevinanielsen/go-fast-cdn/src/handlers/auth"
	"github.com/kevinanielsen/go-fast-cdn/src/models"
	testutils "github.com/kevinanielsen/go-fast-cdn/src/testUtils"
	"github.com/kevinanielsen/go-fast-cdn/src/util"
	"github.com/stretchr/testify/require"
)

// TestVulnerabilitySecurity tests for common security vulnerabilities
func TestVulnerabilitySecurity(t *testing.T) {
	// Create a temporary directory for testing
	tempDir, err := os.MkdirTemp("", "vulnerability-test")
	require.NoError(t, err)
	defer os.RemoveAll(tempDir)

	util.ExPath = tempDir

	// Set environment variables for testing
	os.Setenv("JWT_SECRET", "test-super-secret-jwt-key-for-testing-only")
	defer os.Unsetenv("JWT_SECRET")

	// Initialize database
	database.ConnectToDB()
	database.MigrateWithMedia()
	defer func() {
		dbPath := filepath.Join(util.ExPath, database.DbFolder, database.DbName)
		if err := os.Remove(dbPath); err != nil && !os.IsNotExist(err) {
			t.Error(err)
		}
	}()

	// Create media handler
	mediaHandler := NewMediaHandler(database.NewMediaRepo(database.DB))

	// Create and authenticate a user
	userRepo := database.NewUserRepo(database.DB)
	user := &models.User{
		Email: "test@example.com",
		Role:  "user",
	}
	err = user.HashPassword("SecureP@ssw0rd123")
	require.NoError(t, err)
	err = userRepo.CreateUser(user)
	require.NoError(t, err)

	// Create auth handler to get tokens
	authHandler := authHandlers.NewAuthHandler(userRepo)

	loginReq := authHandlers.LoginRequest{
		Email:    "test@example.com",
		Password: "SecureP@ssw0rd123",
	}

	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)

	jsonData, _ := json.Marshal(loginReq)
	c.Request = httptest.NewRequest(http.MethodPost, "/api/auth/login", bytes.NewBuffer(jsonData))
	c.Request.Header.Add("Content-Type", "application/json")

	authHandler.Login(c)
	require.Equal(t, http.StatusOK, w.Result().StatusCode)

	var authResponse authHandlers.AuthResponse
	err = json.Unmarshal(w.Body.Bytes(), &authResponse)
	require.NoError(t, err)

	t.Run("XSSVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			filename       string
			expectedStatus int
		}{
			{"FilenameWithXSS", "<script>alert('XSS')</script>.png", http.StatusBadRequest},
			{"FilenameWithImgTag", "<img src=x onerror=alert('XSS')>.png", http.StatusBadRequest},
			{"FilenameWithSVGXSS", "<svg onload=alert('XSS')>.png", http.StatusBadRequest},
			{"FilenameWithEventHandlers", "<body onload=alert('XSS')>.png", http.StatusBadRequest},
			{"FilenameWithJavaScript", "javascript:alert('XSS').png", http.StatusBadRequest},
			{"FilenameWithDataURI", "data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=.png", http.StatusBadRequest},
			{"FilenameWithVBScript", "vbscript:alert('XSS').png", http.StatusBadRequest},
			{"FilenameWithCSSExpression", "<style>body{expression(alert('XSS'))}</style>.png", http.StatusBadRequest},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create test image
				img, err := testutils.CreateDummyImage(200, 200)
				require.NoError(t, err)

				// Create multipart form with image
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)

				part, err := writer.CreateFormFile("file", tc.filename)
				require.NoError(t, err)

				err = testutils.EncodeImage(part, img)
				require.NoError(t, err)

				err = writer.Close()
				require.NoError(t, err)

				// Create test request
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodPost, "/api/cdn/upload/media", body)
				c.Request.Header.Add("Content-Type", writer.FormDataContentType())
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

				// Test the unified media upload endpoint
				mediaHandler.HandleMediaUpload(c)

				// Should reject filenames with XSS
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})

	t.Run("CSRFVulnerabilities", func(t *testing.T) {
		// Test for CSRF vulnerabilities by checking if the API properly validates requests
		// In a real application, you would implement CSRF tokens and validate them

		t.Run("MissingCSRFToken", func(t *testing.T) {
			// Create test image
			img, err := testutils.CreateDummyImage(200, 200)
			require.NoError(t, err)

			// Create multipart form with image
			body := &bytes.Buffer{}
			writer := multipart.NewWriter(body)

			part, err := writer.CreateFormFile("file", "test.png")
			require.NoError(t, err)

			err = testutils.EncodeImage(part, img)
			require.NoError(t, err)

			err = writer.Close()
			require.NoError(t, err)

			// Create test request
			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)

			c.Request = httptest.NewRequest(http.MethodPost, "/api/cdn/upload/media", body)
			c.Request.Header.Add("Content-Type", writer.FormDataContentType())
			c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

			// Test the unified media upload endpoint
			mediaHandler.HandleMediaUpload(c)

			// Currently, the API doesn't implement CSRF protection
			// This test documents the current behavior and highlights a potential security improvement
			require.Equal(t, http.StatusOK, w.Result().StatusCode)
		})
	})

	t.Run("SQLInjectionVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			filename       string
			expectedStatus int
		}{
			{"FilenameWithSQLInjection", "test'; DROP TABLE users; --.png", http.StatusBadRequest},
			{"FilenameWithUnionBasedSQLI", "test' UNION SELECT * FROM users --.png", http.StatusBadRequest},
			{"FilenameWithTimeBasedSQLI", "test'; WAITFOR DELAY '0:0:5'--.png", http.StatusBadRequest},
			{"FilenameWithBooleanBasedSQLI", "test' OR 1=1 --.png", http.StatusBadRequest},
			{"FilenameWithStackedQueries", "test'; SELECT * FROM information_schema.tables --.png", http.StatusBadRequest},
			{"FilenameWithCommentSQLI", "test/*comment*/.png", http.StatusBadRequest},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create test image
				img, err := testutils.CreateDummyImage(200, 200)
				require.NoError(t, err)

				// Create multipart form with image
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)

				part, err := writer.CreateFormFile("file", tc.filename)
				require.NoError(t, err)

				err = testutils.EncodeImage(part, img)
				require.NoError(t, err)

				err = writer.Close()
				require.NoError(t, err)

				// Create test request
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodPost, "/api/cdn/upload/media", body)
				c.Request.Header.Add("Content-Type", writer.FormDataContentType())
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

				// Test the unified media upload endpoint
				mediaHandler.HandleMediaUpload(c)

				// Should reject filenames with SQL injection
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})

	t.Run("CommandInjectionVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			filename       string
			expectedStatus int
		}{
			{"FilenameWithCommandInjection", "test; ls -la;.png", http.StatusBadRequest},
			{"FilenameWithPipeInjection", "test| cat /etc/passwd;.png", http.StatusBadRequest},
			{"FilenameWithLogicalAndInjection", "test && rm -rf /;.png", http.StatusBadRequest},
			{"FilenameWithLogicalOrInjection", "test || echo 'hacked';.png", http.StatusBadRequest},
			{"FilenameWithBacktickInjection", "test`rm -rf /`.png", http.StatusBadRequest},
			{"FilenameWithSubshellInjection", "test$(rm -rf /).png", http.StatusBadRequest},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create test image
				img, err := testutils.CreateDummyImage(200, 200)
				require.NoError(t, err)

				// Create multipart form with image
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)

				part, err := writer.CreateFormFile("file", tc.filename)
				require.NoError(t, err)

				err = testutils.EncodeImage(part, img)
				require.NoError(t, err)

				err = writer.Close()
				require.NoError(t, err)

				// Create test request
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodPost, "/api/cdn/upload/media", body)
				c.Request.Header.Add("Content-Type", writer.FormDataContentType())
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

				// Test the unified media upload endpoint
				mediaHandler.HandleMediaUpload(c)

				// Should reject filenames with command injection
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})

	t.Run("PathTraversalVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			filename       string
			expectedStatus int
		}{
			{"FilenameWithRelativePath", "../../../etc/passwd", http.StatusBadRequest},
			{"FilenameWithWindowsPath", "..\\..\\..\\windows\\system32\\config\\sam", http.StatusBadRequest},
			{"FilenameWithURLPath", "file:///etc/passwd", http.StatusBadRequest},
			{"FilenameWithDoubleDots", "test/../etc/passwd", http.StatusBadRequest},
			{"FilenameWithEncodedDots", "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd", http.StatusBadRequest},
			{"FilenameWithDoubleEncodedDots", "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd", http.StatusBadRequest},
			{"FilenameWithBackslashes", "..\\..\\..\\windows\\system32\\config\\sam", http.StatusBadRequest},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create test image
				img, err := testutils.CreateDummyImage(200, 200)
				require.NoError(t, err)

				// Create multipart form with image
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)

				part, err := writer.CreateFormFile("file", tc.filename)
				require.NoError(t, err)

				err = testutils.EncodeImage(part, img)
				require.NoError(t, err)

				err = writer.Close()
				require.NoError(t, err)

				// Create test request
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodPost, "/api/cdn/upload/media", body)
				c.Request.Header.Add("Content-Type", writer.FormDataContentType())
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

				// Test the unified media upload endpoint
				mediaHandler.HandleMediaUpload(c)

				// Should reject filenames with path traversal
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})

	t.Run("HTTPHeaderInjectionVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			headers        map[string]string
			expectedStatus int
		}{
			{"MaliciousUserAgent", map[string]string{"User-Agent": "Mozilla/5.0 (XSS; <script>alert('XSS')</script>)"}, http.StatusOK},
			{"MaliciousReferer", map[string]string{"Referer": "javascript:alert('XSS')"}, http.StatusOK},
			{"MaliciousCookie", map[string]string{"Cookie": "session=<script>alert('XSS')</script>"}, http.StatusOK},
			{"MaliciousXForwardedFor", map[string]string{"X-Forwarded-For": "<script>alert('XSS')</script>"}, http.StatusOK},
			{"MaliciousXRealIP", map[string]string{"X-Real-IP": "<script>alert('XSS')</script>"}, http.StatusOK},
			{"MaliciousHost", map[string]string{"Host": "<script>alert('XSS')</script>"}, http.StatusOK},
			{"MaliciousAccept", map[string]string{"Accept": "<script>alert('XSS')</script>"}, http.StatusOK},
			{"MaliciousAcceptLanguage", map[string]string{"Accept-Language": "<script>alert('XSS')</script>"}, http.StatusOK},
			{"MaliciousAcceptEncoding", map[string]string{"Accept-Encoding": "<script>alert('XSS')</script>"}, http.StatusOK},
			{"MaliciousConnection", map[string]string{"Connection": "<script>alert('XSS')</script>"}, http.StatusOK},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create test image
				img, err := testutils.CreateDummyImage(200, 200)
				require.NoError(t, err)

				// Create multipart form with image
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)

				part, err := writer.CreateFormFile("file", "test.png")
				require.NoError(t, err)

				err = testutils.EncodeImage(part, img)
				require.NoError(t, err)

				err = writer.Close()
				require.NoError(t, err)

				// Create test request
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodPost, "/api/cdn/upload/media", body)
				c.Request.Header.Add("Content-Type", writer.FormDataContentType())
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

				// Add malicious headers
				for key, value := range tc.headers {
					c.Request.Header.Add(key, value)
				}

				// Test the unified media upload endpoint
				mediaHandler.HandleMediaUpload(c)

				// Should handle malicious headers gracefully
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})

	t.Run("XXEVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			filename       string
			content        string
			expectedStatus int
		}{
			{"XXEWithDTD", "test.xml", "<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]><foo>&xxe;</foo>", http.StatusOK},
			{"XXEWithParameterEntity", "test.xml", "<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE foo [ <!ENTITY % xxe SYSTEM \"file:///etc/passwd\"> %xxe; ]><foo></foo>", http.StatusOK},
			{"XXEWithExternalEntity", "test.xml", "<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"http://example.com/malicious.dtd\"> ]><foo>&xxe;</foo>", http.StatusOK},
			{"XXEWithSchema", "test.xml", "<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]><foo xmlns=\"http://example.com/schema\">&xxe;</foo>", http.StatusOK},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create multipart form with XML file
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)

				part, err := writer.CreateFormFile("file", tc.filename)
				require.NoError(t, err)

				_, err = part.Write([]byte(tc.content))
				require.NoError(t, err)

				err = writer.Close()
				require.NoError(t, err)

				// Create test request
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodPost, "/api/cdn/upload/media", body)
				c.Request.Header.Add("Content-Type", writer.FormDataContentType())
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

				// Test the unified media upload endpoint
				mediaHandler.HandleMediaUpload(c)

				// Should handle XXE attempts gracefully
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})

	t.Run("SSRFVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			filename       string
			content        string
			expectedStatus int
		}{
			{"SSRFWithLocalhost", "test.txt", "http://localhost/admin", http.StatusOK},
			{"SSRFWithPrivateIP", "test.txt", "http://192.168.1.1/admin", http.StatusOK},
			{"SSRFWithInternalIP", "test.txt", "http://10.0.0.1/admin", http.StatusOK},
			{"SSRFWithDNSRebinding", "test.txt", "http://example.com@127.0.0.1/admin", http.StatusOK},
			{"SSRFWithIPv6", "test.txt", "http://[::1]/admin", http.StatusOK},
			{"SSRFWithShortenedURL", "test.txt", "http://bit.ly/admin", http.StatusOK},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create multipart form with text file
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)

				part, err := writer.CreateFormFile("file", tc.filename)
				require.NoError(t, err)

				_, err = part.Write([]byte(tc.content))
				require.NoError(t, err)

				err = writer.Close()
				require.NoError(t, err)

				// Create test request
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodPost, "/api/cdn/upload/media", body)
				c.Request.Header.Add("Content-Type", writer.FormDataContentType())
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

				// Test the unified media upload endpoint
				mediaHandler.HandleMediaUpload(c)

				// Should handle SSRF attempts gracefully
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})

	t.Run("OpenRedirectVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			redirectParam  string
			expectedStatus int
		}{
			{"RedirectToMaliciousSite", "redirect_param=http://evil.com", http.StatusOK},
			{"RedirectToJavaScript", "redirect_param=javascript:alert('XSS')", http.StatusOK},
			{"RedirectToDataURI", "redirect_param=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=", http.StatusOK},
			{"RedirectWithCRLFInjection", "redirect_param=/test", http.StatusOK},
			{"RedirectWithDoubleSlash", "redirect_param=//evil.com", http.StatusOK},
			{"RedirectWithEncodedURL", "redirect_param=http%3A%2F%2Fevil.com", http.StatusOK},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create test request with redirect parameter
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodGet, "/api/cdn/media/test.png?type=image&"+tc.redirectParam, nil)
				c.Params = gin.Params{{Key: "filename", Value: "test.png"}}
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

				// Test the unified media metadata endpoint
				mediaHandler.HandleMediaMetadata(c)

				// Should handle open redirect attempts gracefully
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})

	t.Run("PrototypePollutionVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			jsonBody       string
			expectedStatus int
		}{
			{"PrototypePollutionWithToString", "{\"__proto__.toString\": \"malicious\"}", http.StatusOK},
			{"PrototypePollutionWithValueOf", "{\"__proto__.valueOf\": \"malicious\"}", http.StatusOK},
			{"PrototypePollutionWithConstructor", "{\"constructor.prototype.malicious\": \"value\"}", http.StatusOK},
			{"PrototypePollutionWithNestedObject", "{\"__proto__.nested\": {\"malicious\": \"value\"}}", http.StatusOK},
			{"PrototypePollutionWithArray", "{\"__proto__.0\": \"malicious\"}", http.StatusOK},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create test request with malicious JSON
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodPut, "/api/cdn/rename/media", bytes.NewBuffer([]byte(tc.jsonBody)))
				c.Request.Header.Add("Content-Type", "application/json")
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

				// Test the unified media rename endpoint
				mediaHandler.HandleMediaRename(c)

				// Should handle prototype pollution attempts gracefully
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})

	t.Run("HTTPResponseSplittingVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			filename       string
			expectedStatus int
		}{
			{"FilenameWithCRLF", "test%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0a%0d%0a<html><body>Hacked</body></html>.png", http.StatusBadRequest},
			{"FilenameWithDoubleCRLF", "test%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0a%0d%0a<html><body>Hacked</body></html>.png", http.StatusBadRequest},
			{"FilenameWithEncodedCRLF", "test%250d%250aContent-Length:%2500%250d%250a%250d%250aHTTP/1.1%2520200%2520OK%250d%250aContent-Type:%2520text/html%250d%250a%250d%250a<html><body>Hacked</body></html>.png", http.StatusBadRequest},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create test image
				img, err := testutils.CreateDummyImage(200, 200)
				require.NoError(t, err)

				// Create multipart form with image
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)

				part, err := writer.CreateFormFile("file", tc.filename)
				require.NoError(t, err)

				err = testutils.EncodeImage(part, img)
				require.NoError(t, err)

				err = writer.Close()
				require.NoError(t, err)

				// Create test request
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodPost, "/api/cdn/upload/media", body)
				c.Request.Header.Add("Content-Type", writer.FormDataContentType())
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

				// Test the unified media upload endpoint
				mediaHandler.HandleMediaUpload(c)

				// Should reject filenames with HTTP response splitting
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})

	t.Run("HostHeaderInjectionVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			hostHeader     string
			expectedStatus int
		}{
			{"MaliciousHostHeader", "evil.com", http.StatusOK},
			{"HostHeaderWithPort", "evil.com:8080", http.StatusOK},
			{"HostHeaderWithScheme", "http://evil.com", http.StatusOK},
			{"HostHeaderWithCRLF", "evil.com\r\nX-Forwarded-Host: evil.com", http.StatusOK},
			{"HostHeaderWithXSS", "<script>alert('XSS')</script>", http.StatusOK},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create test image
				img, err := testutils.CreateDummyImage(200, 200)
				require.NoError(t, err)

				// Create multipart form with image
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)

				part, err := writer.CreateFormFile("file", "test.png")
				require.NoError(t, err)

				err = testutils.EncodeImage(part, img)
				require.NoError(t, err)

				err = writer.Close()
				require.NoError(t, err)

				// Create test request
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodPost, "/api/cdn/upload/media", body)
				c.Request.Header.Add("Content-Type", writer.FormDataContentType())
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)
				c.Request.Host = tc.hostHeader

				// Test the unified media upload endpoint
				mediaHandler.HandleMediaUpload(c)

				// Should handle malicious host headers gracefully
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})

	t.Run("LDAPInjectionVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			filename       string
			expectedStatus int
		}{
			{"FilenameWithLDAPInjection", "test*)(uid=*))(|(uid=*", http.StatusBadRequest},
			{"FilenameWithLDAPWildcard", "test*", http.StatusBadRequest},
			{"FilenameWithLDAPFilter", "test)(|(objectClass=user)(objectClass=person))", http.StatusBadRequest},
			{"FilenameWithLDAPAttribute", "test)(userPassword=*))", http.StatusBadRequest},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create test image
				img, err := testutils.CreateDummyImage(200, 200)
				require.NoError(t, err)

				// Create multipart form with image
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)

				part, err := writer.CreateFormFile("file", tc.filename)
				require.NoError(t, err)

				err = testutils.EncodeImage(part, img)
				require.NoError(t, err)

				err = writer.Close()
				require.NoError(t, err)

				// Create test request
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodPost, "/api/cdn/upload/media", body)
				c.Request.Header.Add("Content-Type", writer.FormDataContentType())
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

				// Test the unified media upload endpoint
				mediaHandler.HandleMediaUpload(c)

				// Should reject filenames with LDAP injection
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})

	t.Run("NoSQLInjectionVulnerabilities", func(t *testing.T) {
		testCases := []struct {
			name           string
			filename       string
			expectedStatus int
		}{
			{"FilenameWithNoSQLInjection", "test', $where: 'true' }", http.StatusBadRequest},
			{"FilenameWithNoSQLComment", "test', // comment", http.StatusBadRequest},
			{"FilenameWithNoSLOperator", "test', $ne: null }", http.StatusBadRequest},
			{"FilenameWithNoSLRegex", "test', $regex: '.*' }", http.StatusBadRequest},
			{"FilenameWithNoSLWhere", "test', $where: 'function() { return true; }' }", http.StatusBadRequest},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Create test image
				img, err := testutils.CreateDummyImage(200, 200)
				require.NoError(t, err)

				// Create multipart form with image
				body := &bytes.Buffer{}
				writer := multipart.NewWriter(body)

				part, err := writer.CreateFormFile("file", tc.filename)
				require.NoError(t, err)

				err = testutils.EncodeImage(part, img)
				require.NoError(t, err)

				err = writer.Close()
				require.NoError(t, err)

				// Create test request
				w := httptest.NewRecorder()
				c, _ := gin.CreateTestContext(w)

				c.Request = httptest.NewRequest(http.MethodPost, "/api/cdn/upload/media", body)
				c.Request.Header.Add("Content-Type", writer.FormDataContentType())
				c.Request.Header.Add("Authorization", "Bearer "+authResponse.AccessToken)

				// Test the unified media upload endpoint
				mediaHandler.HandleMediaUpload(c)

				// Should reject filenames with NoSQL injection
				require.Equal(t, tc.expectedStatus, w.Result().StatusCode)
			})
		}
	})
}
